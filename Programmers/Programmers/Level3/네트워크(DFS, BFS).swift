//
//  á„‚á…¦á„á…³á„‹á…¯á„á…³(DFS, BFS).swift
//  Programmers
//
//  Created by Junyoung on 5/1/25.
//

import Foundation

/*
 ë¬¸ì œ ì„¤ëª…
 ë„¤íŠ¸ì›Œí¬ë€ ì»´í“¨í„° ìƒí˜¸ ê°„ì— ì •ë³´ë¥¼ êµí™˜í•  ìˆ˜ ìˆë„ë¡ ì—°ê²°ëœ í˜•íƒœë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì»´í“¨í„° Aì™€ ì»´í“¨í„° Bê°€ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ìˆê³ , ì»´í“¨í„° Bì™€ ì»´í“¨í„° Cê°€ ì§ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ìˆì„ ë•Œ ì»´í“¨í„° Aì™€ ì»´í“¨í„° Cë„ ê°„ì ‘ì ìœ¼ë¡œ ì—°ê²°ë˜ì–´ ì •ë³´ë¥¼ êµí™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë”°ë¼ì„œ ì»´í“¨í„° A, B, CëŠ” ëª¨ë‘ ê°™ì€ ë„¤íŠ¸ì›Œí¬ ìƒì— ìˆë‹¤ê³  í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

 ì»´í“¨í„°ì˜ ê°œìˆ˜ n, ì—°ê²°ì— ëŒ€í•œ ì •ë³´ê°€ ë‹´ê¸´ 2ì°¨ì› ë°°ì—´ computersê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ë„¤íŠ¸ì›Œí¬ì˜ ê°œìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ì‹œì˜¤.

 ì œí•œì‚¬í•­
 ì»´í“¨í„°ì˜ ê°œìˆ˜ nì€ 1 ì´ìƒ 200 ì´í•˜ì¸ ìì—°ìˆ˜ì…ë‹ˆë‹¤.
 ê° ì»´í“¨í„°ëŠ” 0ë¶€í„° n-1ì¸ ì •ìˆ˜ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
 ië²ˆ ì»´í“¨í„°ì™€ jë²ˆ ì»´í“¨í„°ê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ computers[i][j]ë¥¼ 1ë¡œ í‘œí˜„í•©ë‹ˆë‹¤.
 computer[i][i]ëŠ” í•­ìƒ 1ì…ë‹ˆë‹¤.
 
 ì…ì¶œë ¥ ì˜ˆ
 n    computers                            return
 3    [[1, 1, 0], [1, 1, 0], [0, 0, 1]]    2
 3    [[1, 1, 0], [1, 1, 1], [0, 1, 1]]    1

 */

func solution_network_dfs_recrusive(_ n:Int, _ computers:[[Int]]) -> Int  {
    // ê° ì»´í“¨í„°ê°€ ë°©ë¬¸ë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
    var visited = [Bool](repeating: false, count: n)
    var visitedArr = [Int]()
    // ë„¤íŠ¸ì›Œí¬(ì—°ê²°ëœ ë©ì–´ë¦¬)ì˜ ê°œìˆ˜ë¥¼ ì…ˆ
    var networkCount = 0
    
    // DFS: í˜„ì¬ ì»´í“¨í„°(node)ì—ì„œ ì—°ê²°ëœ ëª¨ë“  ì»´í“¨í„°ë¥¼ ë°©ë¬¸ ì²˜ë¦¬
    func dfs(_ node: Int) {
        // í˜„ì¬ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆë‹¤ê³  í‘œì‹œ
        visited[node] = true
        visitedArr.append(node)
        print("âœ… ë°©ë¬¸ ë…¸ë“œ: \(visitedArr.map{ $0 + 1 })")
        print("âœ… ë°©ë¬¸ ì‹œì‘: \(node + 1)ë²ˆ ì»´í“¨í„°")
        
        // 0ë¶€í„° n-1ê¹Œì§€ ëª¨ë“  ì»´í“¨í„°ì— ëŒ€í•´
        for i in 0..<n {
            // ë§Œì•½ nodeì™€ iê°€ ì—°ê²°ë˜ì–´ ìˆê³ , iê°€ ì•„ì§ ë°©ë¬¸ë˜ì§€ ì•Šì•˜ë‹¤ë©´
            if computers[node][i] == 1 && !visited[i] {
                print("ğŸ”— \(node + 1)ë²ˆ ì»´í“¨í„° â†’ \(i + 1)ë²ˆ ì»´í“¨í„° ì—°ê²°ë¨ (ì•„ì§ ë°©ë¬¸ ì•ˆ í•¨)")
                print("ğŸ”— \(i + 1)ë²ˆ ì»´í“¨í„° ì¬ê·€ íƒìƒ‰ ì‹œì‘")
                dfs(i) // ì—°ê²°ëœ ì»´í“¨í„°ë¡œ ì¬ê·€ íƒìƒ‰
            } else if computers[node][i] == 1 && visited[i] {
                print("ğŸ” \(node + 1)ë²ˆ ì»´í“¨í„° â†’ \(i + 1)ë²ˆ ì»´í“¨í„° ì—°ê²°ë¨ (ì´ë¯¸ ë°©ë¬¸í•¨)")
            } else {
                print("âŒ \(node + 1)ë²ˆ ì»´í“¨í„° â†’ \(i + 1)ë²ˆ ì»´í“¨í„° ì—°ê²°ë˜ì§€ ì•ŠìŒ")
            }
        }
        print("â¬…ï¸ \(node + 1)ë²ˆ ì»´í“¨í„° DFS ì¢…ë£Œ")
    }
    
    // ëª¨ë“  ì»´í“¨í„°ì— ëŒ€í•´ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì»´í“¨í„°ê°€ ìˆìœ¼ë©´ DFS ì‹¤í–‰
    for i in 0..<n {
        // ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì»´í“¨í„°ë¼ë©´, ìƒˆë¡œìš´ ë„¤íŠ¸ì›Œí¬ì˜ ì‹œì‘
        if !visited[i] {
            print("==== \(i)ë²ˆ ì»´í“¨í„°ì—ì„œ DFS ì‹œì‘ ====")
            // ì´ ì»´í“¨í„°ë¥¼ ì‹œì‘ìœ¼ë¡œ ì—°ê²°ëœ ëª¨ë“  ì»´í“¨í„° ë°©ë¬¸ ì²˜ë¦¬ + ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜ ì¦ê°€
            dfs(i)
            networkCount += 1
            print("ğŸŒ ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜ ì¦ê°€ â†’ í˜„ì¬ê¹Œì§€ \(networkCount)\n")
        }
    }
    
    return networkCount
}

func solution_network_bfs_queue(_ n:Int, _ computers:[[Int]]) -> Int  {
    var visited = [Bool](repeating: false, count: n)
    var networkCount = 0
    var visitedArr = [Int]()
    
    for i in 0..<n {
        if !visited[i] {
            var queue = [i]  // í ì´ˆê¸°í™”
            print("==== \(i + 1)ë²ˆ ì»´í“¨í„°ì—ì„œ BFS ì‹œì‘ ====")
            
            while !queue.isEmpty {
                let node = queue.removeFirst()
                print("âœ… ë°©ë¬¸ ì‹œì‘: \(node + 1)ë²ˆ ì»´í“¨í„°")

                if visited[node] {
                    print("ğŸ” \(node + 1)ë²ˆ ì»´í“¨í„° ì´ë¯¸ ë°©ë¬¸í•¨ â†’ ìŠ¤í‚µ")
                    continue
                }
                
                visited[node] = true
                print("âœ… \(node + 1)ë²ˆ ì»´í“¨í„° ë°©ë¬¸")
                
                visitedArr.append(node)
                print("âœ… ë°©ë¬¸ ë…¸ë“œ: \(visitedArr.map{ $0 + 1 })")
                
                for j in 0..<n {
                    if computers[node][j] == 1 && !visited[j] {
                        print("ğŸ”— \(node + 1) â†’ \(j + 1) ì—°ê²°ë¨ (íì— ì¶”ê°€)")
                        queue.append(j)
                        print("ğŸ”— í: \(queue.map { $0 + 1})")
                    } else if computers[node][j] == 1 && visited[j] {
                        print("ğŸ” \(node + 1) â†’ \(j + 1) ì—°ê²°ë¨ (ì´ë¯¸ ë°©ë¬¸)")
                    } else {
                        print("âŒ \(node + 1) â†’ \(j + 1) ì—°ê²°ë˜ì§€ ì•ŠìŒ")
                    }
                }
            }
            
            networkCount += 1
            print("ğŸŒ ë„¤íŠ¸ì›Œí¬ ê°œìˆ˜ ì¦ê°€ â†’ í˜„ì¬ê¹Œì§€ \(networkCount)\n")
        }
    }
    
    return networkCount
}
